<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>World Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      background: #f8f9fa;
    }

    /* Container for the entire app */
    .app-container {
      display: flex;
      height: 100vh;
      position: relative;
    }

    /* Sidebar responsive */
    .sidebar {
      width: 18%;
      min-width: 280px;
      max-width: 400px;
      background: #082032;
      color: white;
      padding: 1.5rem;
      box-sizing: border-box;
      height: 100vh;
      z-index: 999;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      border-right: 1px solid #1f2d3d;
      overflow-y: auto;
      overflow-x: hidden;
    }

    #map {
      flex: 1;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background-color: #FAF8F4;
      margin-left: 0;
      margin-right: 0;
    }

    #map.full-width {
      width: 100% !important;
    }

    .toggle-info-btn {
      position: fixed;
      right: 20px;
      top: 20px;
      z-index: 1001;
      background: #082032;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .toggle-info-btn:hover {
      background: #0a2540;
    }

    .toggle-info-btn.panel-hidden {
      right: 20px;
      background: #4a90e2;
    }

    /* Info box responsive */
    .info {
      position: fixed;
      height: 100vh;
      top: 0;
      right: 0;
      z-index: 1000;
      background: #082032;
      color: white;
      padding: 1.5rem;
      padding-bottom: 3rem;
      font-size: 12px;
      line-height: 1.8;
      width: 18%;
      min-width: 280px;
      max-width: 350px;
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.4);
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box;
      display: block;
      pointer-events: auto;
    }

    /* Legend box responsive */
    .legend-box {
      position: relative;
      margin-top: 20px;
      z-index: 1000;
      width: calc(100% - 5px);
      max-width: 100%;
      min-height: 100px;
      background: white;
      color: black;
      border-radius: 16px;
      padding: 1rem;
      font-size: 11px;
      line-height: 1.6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      box-sizing: border-box;
      overflow-x: hidden;
      word-wrap: break-word;
      flex-shrink: 0;
    }

    /* Mobile styles */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: auto;
        max-height: 40vh;
        min-width: unset;
        max-width: unset;
        border-right: none;
        border-bottom: 1px solid #1f2d3d;
      }

      #map {
        height: 60vh;
      }

      .info {
        position: fixed;
        bottom: 0;
        right: 0;
        left: 0;
        top: auto;
        height: 50vh;
        width: 100%;
        max-width: unset;
        min-width: unset;
        border-radius: 20px 20px 0 0;
        transform: translateY(calc(100% - 60px));
        transition: transform 0.3s ease;
      }

      .info.active {
        transform: translateY(0);
      }

      .legend-box {
        position: relative;
        margin-top: 20px;
        width: calc(100% - 5px);
        max-width: 100%;
        box-sizing: border-box;
      }

      .leaflet-top.leaflet-left {
        left: 10px;
        top: 10px;
      }
    }

    /* Tablet styles */
    @media (min-width: 769px) and (max-width: 1024px) {
      .sidebar {
        width: 30%;
        min-width: 250px;
      }

      .info {
        width: 30%;
        min-width: 250px;
      }

      .legend-box {
        width: calc(100% - 5px);
        max-width: 100%;
        box-sizing: border-box;
      }
    }

    /* Keep your existing element styles */
    .info-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding-bottom: 6px;
      border-bottom: 1.5px solid #2a3f5f;
    }

    .info-header img {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid #ddd;
    }

    .info-header h2 {
      margin: 0;
      font-size: 22px;
      font-weight: bold;
      color: white;
    }

    .section-title {
      margin: 16px 0 6px;
      font-weight: bold;
      text-decoration: underline;
      text-underline-offset: 2px;
      white-space: nowrap;
    }

    .data-row {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
      white-space: nowrap;
    }

    .data-key {
      text-align: left;
      flex: 1;
    }

    .data-value {
      text-align: right;
      flex: 1;
    }

    .sidebar h2 {
      margin: 0 0 1.25rem;
      font-size: 1.25rem;
      font-weight: bold;
      padding-bottom: 0.625rem;
      border-bottom: 1px solid #2a3f5f;
    }

    .sidebar h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    .sidebar label {
      font-weight: 600;
      display: block;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      color: #a8b3c5;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar select {
      width: 100%;
      padding: 0.625rem 0.75rem;
      margin-top: 0.3rem;
      border-radius: 8px;
      border: 1px solid #2a3f5f;
      background-color: #0a1929;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .sidebar select:hover {
      border-color: #4dabf7;
      background-color: #1a2332;
    }

    .sidebar select:focus {
      outline: none;
      border-color: #4dabf7;
      box-shadow: 0 0 0 2px rgba(77, 171, 247, 0.2);
    }

    /* Position zoom controls properly */
    .leaflet-control-zoom {
      margin-left: 10px !important;
      margin-top: 10px !important;
    }

    .legend-colors {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 10px 0;
    }

    .legend-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 2px;
    }

    .legend-color-box {
      width: 20px;
      height: 20px;
      min-width: 20px;
      border-radius: 3px;
      border: 1px solid #ccc;
      flex-shrink: 0;
    }

    #resetButton:hover {
      background-color: #357abd !important;
    }

    #compareButton:hover {
      background-color: #27ae60 !important;
    }

    #doCompareButton:hover {
      background-color: #2980b9 !important;
    }

    .compare-info {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      display: none;
    }

    .compare-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
    }

    .compare-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .compare-table th {
      background-color: #082032;
      color: white;
      padding: 12px;
      text-align: left;
      font-weight: 600;
    }

    .compare-table td {
      padding: 10px 12px;
      border-bottom: 1px solid #e0e0e0;
    }

    .compare-table tr:nth-child(even) {
      background-color: #f8f9fa;
    }

    .metric-name {
      font-weight: 500;
      color: #333;
    }

    .value-better {
      color: #27ae60;
      font-weight: 600;
    }

    .value-worse {
      color: #e74c3c;
      font-weight: 600;
    }

    .value-equal {
      color: #333;
    }

    /* Mobile info box toggle */
    @media (max-width: 768px) {
      .info::before {
        content: '';
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 4px;
        background: #4a5568;
        border-radius: 2px;
      }

      .info-header {
        cursor: pointer;
      }
    }

    /* Loading state */
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }

    .loading::after {
      content: 'Loading...';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 9999;
    }
  </style>

</head>

<body>

  <button class="toggle-info-btn" onclick="app.toggleInfoPanel()">
    <span id="toggleText">Hide Info</span>
  </button>

  <div class="app-container">
    <div class="sidebar">
      <h2>Filters</h2>
      <label for="countrySelect">Country</label>
      <select id="countrySelect">
        <option value="">All Countries</option>
      </select>

      <label for="categorySelect">Indicators<br></label>
      <select id="categorySelect">
        <option value="">Select type</option>
        <option value="demographics_indicators">Demographics Indicators</option>
        <option value="economic_indicators" selected>Economic Indicators</option>
        <option value="health_systems_overview">Health Systems Overview</option>
        <option value="service_availability">Service Availability</option>
        <option value="market_overview">Market Overview</option>
        <option value="health_financing">Health Financing</option>
      </select>

      <label for="metricSelect">Metric<br></label>
      <select id="metricSelect">
        <option value="">Select type</option>
      </select>

      <!-- Action Buttons Container -->
      <div style="margin-top: 15px; margin-bottom: 15px;">
        <button id="resetButton" style="
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    background-color: #4a90e2;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
  ">Reset View</button>

        <button id="compareButton" style="
    width: 100%;
    padding: 10px;
    background-color: #2ecc71;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
  ">Compare Countries</button>
      </div>

      <!-- Compare Panel (Initially Hidden) -->
      <div id="comparePanel" style="
  display: none;
  margin-bottom: 20px;
  padding: 15px;
  background-color: #0a1929;
  border-radius: 8px;
  border: 1px solid #2a3f5f;
">
        <label style="color: #a8b3c5; font-size: 12px; display: block; margin-bottom: 8px;">Select countries to
          compare:</label>
        <select id="compareCountry1" style="
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border-radius: 6px;
    border: 1px solid #2a3f5f;
    background-color: #0a1929;
    color: white;
    font-size: 12px;
  ">
          <option value="">Select first country</option>
        </select>

        <select id="compareCountry2" style="
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border-radius: 6px;
    border: 1px solid #2a3f5f;
    background-color: #0a1929;
    color: white;
    font-size: 12px;
  ">
          <option value="">Select second country</option>
        </select>

        <button id="doCompareButton" style="
    width: 100%;
    padding: 8px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
  ">Show Comparison</button>
      </div>

      <h2 id="legendTitle">Scale</h2>
      <div id="legendBox" class="legend-box">
        <div id="legendColors" class="legend-colors"></div>
        <div id="legendLabels" class="legend-labels"></div>
      </div>

    </div>

    <div id="map">
      <div id="infoBox" class="info"></div>
      <div id="compareInfo" class="compare-info"></div>

    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // REACTIVE STATE MANAGEMENT SYSTEM
    class ReactiveState {
      constructor(initialState) {
        this.state = initialState;
        this.listeners = new Map();
        this.computedValues = new Map();
      }

      // Subscribe to state changes
      subscribe(path, callback) {
        if (!this.listeners.has(path)) {
          this.listeners.set(path, new Set());
        }
        this.listeners.get(path).add(callback);

        // Return unsubscribe function
        return () => {
          const listeners = this.listeners.get(path);
          if (listeners) {
            listeners.delete(callback);
          }
        };
      }

      // Get state value
      get(path) {
        const keys = path.split('.');
        let value = this.state;
        for (const key of keys) {
          value = value?.[key];
        }
        return value;
      }

      // Set state value and notify listeners
      set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        let obj = this.state;

        for (const key of keys) {
          if (!obj[key]) obj[key] = {};
          obj = obj[key];
        }

        const oldValue = obj[lastKey];
        if (oldValue === value) return; // No change

        obj[lastKey] = value;

        // Notify listeners
        this.notifyListeners(path, value, oldValue);
      }

      // Notify all relevant listeners
      notifyListeners(path, newValue, oldValue) {
        // Notify exact path listeners
        const exactListeners = this.listeners.get(path);
        if (exactListeners) {
          exactListeners.forEach(callback => callback(newValue, oldValue, path));
        }

        // Notify parent path listeners
        const pathParts = path.split('.');
        for (let i = pathParts.length - 1; i > 0; i--) {
          const parentPath = pathParts.slice(0, i).join('.');
          const parentListeners = this.listeners.get(parentPath);
          if (parentListeners) {
            parentListeners.forEach(callback => callback(this.get(parentPath), null, parentPath));
          }
        }

        // Update computed values
        this.updateComputedValues();
      }

      // Define computed values
      computed(name, dependencies, compute) {
        this.computedValues.set(name, {dependencies, compute});

        // Subscribe to dependencies
        dependencies.forEach(dep => {
          this.subscribe(dep, () => {
            const result = compute(this);
            this.set(`computed.${name}`, result);
          });
        });

        // Initial computation
        const result = compute(this);
        this.set(`computed.${name}`, result);
      }

      // Update all computed values
      updateComputedValues() {
        this.computedValues.forEach((config, name) => {
          const result = config.compute(this);
          const currentValue = this.get(`computed.${name}`);
          if (result !== currentValue) {
            this.set(`computed.${name}`, result);
          }
        });
      }
    }

    // APPLICATION CLASS
    class WorldHeatmapApp {
      constructor() {
        // Initialize reactive state
        this.state = new ReactiveState({
          ui: {
            infoPanelVisible: true,
            comparePanelVisible: false,
            compareModalVisible: false,
            loading: false
          },
          filters: {
            country: '',
            category: 'economic_indicators',
            metric: 'gdp'
          },
          compare: {
            country1: '',
            country2: ''
          },
          currentInfo: {
            country: null
          },
          computed: {}
        });

        // Data and configuration
        this.countryData = {};

        this.config = {
          categoryMetrics: {
            demographics_indicators: ['population', 'population_growth', 'life_expectancy', 'age_0_14', 'age_15_64', 'age_65_above', 'urban_area', 'rural_area'],
            economic_indicators: ['gdp', 'income_group', 'gdp_growth', 'gini_index'],
            health_systems_overview: ['system', 'uhc', 'haq'],
            service_availability: ['physicians', 'nurses', 'beds'],
            market_overview: ['mars', 'prescription', 'generic', 'patented', 'national_cancer_guideline', 'national_cancer_plan'],
            health_financing: ['health_spending', 'external_funding', 'oop_funding', 'government_funding', 'others_funding']
          },
          metricDisplayNames: {
            population: 'Population',
            population_growth: 'Population Growth',
            life_expectancy: 'Life Expectancy at Birth',
            age_0_14: 'Age 0-14 (%)',
            age_15_64: 'Age 15-64 (%)',
            age_65_above: 'Age 65+ (%)',
            urban_area: 'Urban Area (%)',
            rural_area: 'Rural Area (%)',
            gdp: 'GDP per capita',
            income_group: 'Income Group',
            gdp_growth: 'GDP Growth',
            gini_index: 'GINI Index',
            system: 'System Type',
            uhc: 'Universal Health Coverage (UHC)',
            haq: 'Health Access & Quality (HAQ)',
            physicians: 'Physicians per 10,000',
            nurses: 'Nurses and Midwives per 10,000',
            beds: 'Hospital Beds per 10,000',
            mars: 'Market Access Risk Score (MARS)',
            prescription: 'Prescription (%)',
            generic: 'Generic (%)',
            patented: 'Patented (%)',
            national_cancer_guideline: 'National Cancer Guideline',
            national_cancer_plan: 'National Cancer Plan',
            health_spending: 'Health Spending per capita',
            external_funding: 'External Funding (%)',
            oop_funding: 'OOP Funding (%)',
            government_funding: 'Government Funding (%)',
            others_funding: 'Others (%)'
          },
          colorSchemes: {
            gdp: {
              domain: [1135, 4465, 13845],
              range: ['#A7DBDE', '#84B1B8', '#3F5F79', '#1D3558'],
              labels: ['Low (≤ $1,135)', 'Lower-middle ($1,136 - $4,465)', 'Upper-middle ($4,466 - $13,845)', 'High (> $13,845)']
            },
            gdp_growth: {
              domain: [0, 2, 3],
              range: ['#A7DBDE', '#84B1B8', '#3F5F79', '#1D3558'],
              labels: ['Negative (< 0%)', 'Weak (0 - 2%)', 'Moderate (2 - 3%)', 'Strong (> 3%)']
            },
            gini_index: {
              domain: [30, 40, 50],
              range: ['#A7DBDE', '#84B1B8', '#3F5F79', '#1D3558'],
              labels: ['Low inequality (< 30)', 'Moderate inequality (30 - 39)', 'High inequality (40 - 49)', 'Very high inequality (≥ 50)']
            }
          }
        };

        // Cache DOM elements
        this.elements = {
          infoBox: document.getElementById('infoBox'),
          legendColors: document.getElementById('legendColors'),
          legendLabels: document.getElementById('legendLabels'),
          countrySelect: document.getElementById('countrySelect'),
          categorySelect: document.getElementById('categorySelect'),
          metricSelect: document.getElementById('metricSelect'),
          comparePanel: document.getElementById('comparePanel'),
          compareInfo: document.getElementById('compareInfo'),
          resetButton: document.getElementById('resetButton'),
          compareButton: document.getElementById('compareButton'),
          doCompareButton: document.getElementById('doCompareButton'),
          toggleText: document.getElementById('toggleText'),
          map: document.getElementById('map')
        };

        // Map-related properties
        this.map = null;
        this.geoLayer = null;
        this.geoData = null;

        // Format cache
        this.formatCache = new Map();

        // Initialize the app
        this.init();
      }

      init() {
        // Initialize map
        this.initMap();

        // Set up reactive subscriptions
        this.setupReactiveSubscriptions();

        // Set up event listeners
        this.setupEventListeners();

        // Load map data (this will now also load CSV data)
        this.loadMapData();
      }

      async loadCSVData() {
        try {
          // Read the CSV file
          const response = await fetch('./data_raw.csv');
          const csvText = await response.text();

          // Parse CSV
          const lines = csvText.split('\n');
          const headers = lines[0].split(',');

          // Process each country row
          for (let i = 1; i < lines.length; i++) {
            const row = lines[i].split(',');
            if (row.length < 31) continue; // Skip incomplete rows

            const countryName = row[0].trim().replace(/"/g, '');
            if (!countryName) continue;

            // Helper function to parse values
            const parseValue = (value) => {
              if (!value || value.trim() === '' || value.trim().toLowerCase() === 'null') return null;
              const num = parseFloat(value);
              return isNaN(num) ? value.trim().replace(/"/g, '') : num;
            };

            // Create country data object
            this.countryData[countryName] = {
              code: parseValue(row[1]),
              demographics_indicators: {
                population: parseValue(row[2]),
                population_growth: parseValue(row[3]),
                life_expectancy: parseValue(row[4]),
                age_0_14: parseValue(row[5]),
                age_15_64: parseValue(row[6]),
                age_65_above: parseValue(row[7]),
                urban_area: parseValue(row[8]),
                rural_area: parseValue(row[9])
              },
              economic_indicators: {
                gdp: parseValue(row[10]),
                income_group: parseValue(row[11]),
                gdp_growth: parseValue(row[12]),
                gini_index: parseValue(row[13])
              },
              health_systems_overview: {
                system: parseValue(row[14]),
                uhc: parseValue(row[15]),
                haq: parseValue(row[16])
              },
              service_availability: {
                physicians: parseValue(row[17]),
                nurses: parseValue(row[18]),
                beds: parseValue(row[19])
              },
market_overview: {
  mars: parseValue(row[20]),
  prescription: parseValue(row[21]),
  generic: parseValue(row[22]),
  patented: parseValue(row[23]),
  national_cancer_guideline: parseValue(row[24]),
  national_cancer_plan: parseValue(row[25])
},
              health_financing: {
                health_spending: parseValue(row[26]),
                external_funding: parseValue(row[27]),
                oop_funding: parseValue(row[28]),
                government_funding: parseValue(row[29]),
                others_funding: parseValue(row[30])
              }
            };
          }

          console.log('CSV data loaded successfully:', Object.keys(this.countryData).length, 'countries');
        } catch (error) {
          console.error('Error loading CSV:', error);
          alert('Error loading CSV file. Please check the file path and ensure the file exists.');
        }
      }

      async loadMapData() {
        this.setLoading(true);

        try {
          // First load the CSV data
          await this.loadCSVData();

          // Then load the map data
          const response = await fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json');
          const geo = await response.json();

          // Filter to only include countries with data
          this.geoData = {
            ...geo,
            features: geo.features.filter(f => this.countryData[f.properties.name])
          };

          // Populate country dropdown
          const countries = Object.keys(this.countryData).sort();
          countries.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            this.elements.countrySelect.appendChild(option);
          });

          // Initial draw
          this.updateMetricDropdown();
          this.state.set('currentInfo.country', 'All Countries');
          this.drawMap();

          this.setLoading(false);
        } catch (error) {
          console.error('Error loading data:', error);
          this.elements.infoBox.innerHTML = '<div style="padding: 20px;">Error loading data. Please refresh the page.</div>';
          this.setLoading(false);
        }
      }

      initMap() {
        this.map = L.map('map', {
          minZoom: 2,
          maxZoom: 5,
          zoomSnap: 1,
          zoomDelta: 1,
          worldCopyJump: false,
          attributionControl: false,
          zoomControl: false
        }).setView([40, 65], 2);

        L.control.zoom({position: 'topleft'}).addTo(this.map);
      }

setupReactiveSubscriptions() {
  // Subscribe to filter changes
  this.state.subscribe('filters', (filters) => {
    if (filters.category && filters.metric) {
      this.drawMap();
    }
  });

  // Subscribe to UI state changes
  this.state.subscribe('ui.infoPanelVisible', (visible) => {
    this.updateInfoPanelVisibility(visible);
  });

  this.state.subscribe('ui.comparePanelVisible', (visible) => {
    this.elements.comparePanel.style.display = visible ? 'block' : 'none';
  });

  this.state.subscribe('ui.compareModalVisible', (visible) => {
    this.elements.compareInfo.style.display = visible ? 'block' : 'none';
  });

  this.state.subscribe('currentInfo.country', (country) => {
    if (country !== null) {
      this.updateInfoDisplay(country);
    }
  });

  // ADD THIS NEW SUBSCRIPTION - this is the key fix!
  this.state.subscribe('currentInfo.country', (country) => {
    if (country !== null) {
      this.updateInfoDisplay(country);
      // Update legend to show current country's position
      const category = this.state.get('filters.category');
      const metric = this.state.get('filters.metric');
      if (category && metric && this.geoData) {
        const vals = [];
        this.geoData.features.forEach(f => {
          const val = this.getVal(f.properties.name, metric);
          if (val !== undefined && val !== null && val !== '') {
            vals.push(val);
          }
        });
        if (vals.length > 0) {
          const {scale, labels} = this.getColorScale(metric, vals);
          this.updateLegend(metric, scale, labels, vals);
        }
      }
    }
  });

  // Define computed values
  this.state.computed('availableMetrics', ['filters.category'], (state) => {
    const category = state.get('filters.category');
    return this.config.categoryMetrics[category] || [];
  });
}

      setupEventListeners() {
        // Filter controls
        this.elements.categorySelect.addEventListener('change', (e) => {
          this.state.set('filters.category', e.target.value);
          this.updateMetricDropdown();
        });

        this.elements.metricSelect.addEventListener('change', (e) => {
          this.state.set('filters.metric', e.target.value);
        });

        this.elements.countrySelect.addEventListener('change', (e) => {
          this.state.set('filters.country', e.target.value);
        });

        // Buttons
        this.elements.resetButton.addEventListener('click', () => this.resetView());
        this.elements.compareButton.addEventListener('click', () => this.toggleComparePanel());
        this.elements.doCompareButton.addEventListener('click', () => this.compareCountries());

        // Window resize
        window.addEventListener('resize', this.debounce(() => {
          this.map.invalidateSize();
        }, 300));

      }

      updateMetricDropdown() {
        const category = this.state.get('filters.category');
        const metrics = this.state.get('computed.availableMetrics');

        this.elements.metricSelect.innerHTML = '<option value="">Select metric</option>';

        metrics.forEach(metric => {
          const option = document.createElement('option');
          option.value = metric;
          option.textContent = this.config.metricDisplayNames[metric] || metric;
          this.elements.metricSelect.appendChild(option);
        });

        if (metrics.length > 0) {
          this.elements.metricSelect.value = metrics[0];
          this.state.set('filters.metric', metrics[0]);
        }
      }

      drawMap() {
        const category = this.state.get('filters.category');
        const metric = this.state.get('filters.metric');
        const country = this.state.get('filters.country');

        if (!this.geoData || !category || !metric) return;

        // Set loading state
        this.setLoading(true);

        // Remove existing layer
        if (this.geoLayer) {
          this.map.removeLayer(this.geoLayer);
          this.geoLayer = null;
        }

        // Get all values for the metric
        const vals = [];
        this.geoData.features.forEach(f => {
          const val = this.getVal(f.properties.name, metric);
          if (val !== undefined && val !== null && val !== '') {
            vals.push(val);
          }
        });

        if (vals.length === 0) {
          this.setLoading(false);
          return;
        }

        // Calculate color scale
        const {scale, labels} = this.getColorScale(metric, vals);

        // Create layer
        this.geoLayer = L.geoJSON(this.geoData, {
          style: feature => {
            const val = this.getVal(feature.properties.name, metric);
            const hasValue = val !== undefined && val !== null && val !== '';

            return {
              fillColor: hasValue ? scale(val) : '#e8eaed',
              color: '#333',
              weight: 1,
              fillOpacity: 0.7
            };
          },
          onEachFeature: (feature, layer) => {
            layer.on({
              mouseover: (e) => {
                e.target.setStyle({weight: 2, color: '#000'});
                this.state.set('currentInfo.country', feature.properties.name);
              },
              mouseout: (e) => {
                this.geoLayer.resetStyle(e.target);
              },
              click: (e) => {
                this.map.fitBounds(e.target.getBounds());
                this.state.set('filters.country', feature.properties.name);
              }
            });
          }
        }).addTo(this.map);

        // Update legend
        this.updateLegend(metric, scale, labels, vals);

        // Handle country highlight
        if (country) {
          const target = this.geoLayer.getLayers().find(l => l.feature.properties.name === country);
          if (target) {
            this.map.fitBounds(target.getBounds());
            this.state.set('currentInfo.country', country);
          }
        }

        this.setLoading(false);
      }

      getColorScale(metric, vals) {
        let scale, labels;

        if (this.config.colorSchemes[metric]) {
          const scheme = this.config.colorSchemes[metric];
          scale = d3.scaleThreshold().domain(scheme.domain).range(scheme.range);
          labels = scheme.labels;
        } else if (metric === 'system' || metric === 'income_group' || metric === 'national_cancer_guideline' || metric === 'national_cancer_plan') {
          const uniqueValues = [...new Set(vals)];
          scale = d3.scaleOrdinal()
            .domain(uniqueValues)
            .range(d3.schemeSet3);
          labels = uniqueValues;
        } else {
          const min = Math.min(...vals);
          const max = Math.max(...vals);
          scale = d3.scaleSequential(d3.interpolateYlGnBu).domain([min, max]);
        }

        return {scale, labels};
      }

updateLegend(metric, scale, labels, vals) {
  this.elements.legendColors.innerHTML = '';

  const wrapper = document.createElement('div');
  wrapper.style.cssText = 'display:flex;flex-direction:column;justify-content:center;min-height:80px;width:100%';

  if (labels) {
    labels.forEach((label, index) => {
      const color = this.config.colorSchemes[metric]
        ? this.config.colorSchemes[metric].range[index]
        : scale(label);

      const row = document.createElement('div');
      row.className = 'legend-row';
      row.innerHTML = `
        <div class="legend-color-box" style="background:${color}"></div>
        <div>${label === 'null' || label === null ? 'N/A' : label}</div>
      `;
      wrapper.appendChild(row);
    });
  } else {
    const container = document.createElement('div');
    container.style.cssText = 'display:flex;flex-direction:column;gap:8px';

    // Create gradient bar container
    const gradientContainer = document.createElement('div');
    gradientContainer.style.cssText = 'position:relative;width:100%';

    const gradient = document.createElement('div');
    gradient.style.cssText = `background:linear-gradient(to right, ${scale.range()[0]}, ${scale.range()[scale.range().length - 1]});height:20px;width:100%;border:1px solid #ccc;border-radius:3px`;

    // Add position indicator for current country
    const currentCountry = this.state.get('currentInfo.country');
    if (currentCountry && currentCountry !== 'All Countries' && this.countryData[currentCountry]) {
      const currentValue = this.getVal(currentCountry, metric);
      if (currentValue !== null && currentValue !== undefined) {
        const min = Math.min(...vals);
        const max = Math.max(...vals);
        const position = ((currentValue - min) / (max - min)) * 100;
        
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          position: absolute;
          top: -5px;
          left: ${Math.max(0, Math.min(100, position))}%;
          transform: translateX(-50%);
          width: 0;
          height: 0;
          border-left: 6px solid transparent;
          border-right: 6px solid transparent;
          border-top: 10px solid #ff4444;
          z-index: 10;
        `;
        
        // Add value label
        const valueLabel = document.createElement('div');
        valueLabel.style.cssText = `
          position: absolute;
          top: -25px;
          left: ${Math.max(0, Math.min(100, position))}%;
          transform: translateX(-50%);
          background: #ff4444;
          color: white;
          padding: 2px 6px;
          border-radius: 4px;
          font-size: 10px;
          font-weight: bold;
          white-space: nowrap;
        `;
        valueLabel.textContent = this.formatValue(currentValue);
        
        gradientContainer.appendChild(indicator);
        gradientContainer.appendChild(valueLabel);
      }
    }

    gradientContainer.appendChild(gradient);

    const labelsDiv = document.createElement('div');
    labelsDiv.style.cssText = 'display:flex;justify-content:space-between;width:100%;font-size:13px';
    labelsDiv.innerHTML = `
      <div>${Math.min(...vals).toFixed(1)}</div>
      <div>${Math.max(...vals).toFixed(1)}</div>
    `;

    container.appendChild(gradientContainer);
    container.appendChild(labelsDiv);
    wrapper.appendChild(container);
  }

  this.elements.legendColors.appendChild(wrapper);
}
      updateInfoDisplay(countryName) {
        const data = this.countryData[countryName];
        if (!data) {
          this.elements.infoBox.innerHTML = `<div class="info-header"><h2>${countryName}</h2></div><div>No data</div>`;
          return;
        }

        this.elements.infoBox.innerHTML = this.createInfoHTML(countryName, data);
        this.elements.infoBox.scrollTop = 0;

        // Set up mobile touch handlers after content is loaded
        if (window.innerWidth <= 768) {
          this.setupMobileTouchHandlers();
        }
      }

      createInfoHTML(name, data) {
        const code = data.code?.toLowerCase() || '';
        const d = data;

        return `
          <div class="info-header">
            ${code && /^[a-z]{2}$/.test(code) ? `<img src="https://flagcdn.com/w40/${code}.png" onerror="this.style.display='none'" alt="${name} flag">` : ''}
            <h2>${name}</h2>
          </div>

          <div class="section-title">👥 <u>Demographics Indicators</u></div>
          ${this.createDataRows([
          ['Population', d.demographics_indicators?.population?.toLocaleString()],
          ['Population Growth', this.formatValue(d.demographics_indicators?.population_growth, false, true)],
          ['Life Expectancy', `${this.formatValue(d.demographics_indicators?.life_expectancy)} years`],
          ['Age 0-14', this.formatValue(d.demographics_indicators?.age_0_14, false, true)],
          ['Age 15-64', this.formatValue(d.demographics_indicators?.age_15_64, false, true)],
          ['Age 65+', this.formatValue(d.demographics_indicators?.age_65_above, false, true)],
          ['Urban Area', this.formatValue(d.demographics_indicators?.urban_area, false, true)],
          ['Rural Area', this.formatValue(d.demographics_indicators?.rural_area, false, true)]
        ])}

          <div class="section-title">💰 <u>Economic Indicators</u></div>
          ${this.createDataRows([
          ['GDP per capita', d.economic_indicators?.gdp ? `$${this.formatValue(d.economic_indicators?.gdp, true)}` : 'N/A'],
          ['Income Group', this.formatValue(d.economic_indicators?.income_group)],
          ['GDP Growth', this.formatValue(d.economic_indicators?.gdp_growth, false, true)],
          ['GINI Index', this.formatValue(d.economic_indicators?.gini_index)]
        ])}

          <div class="section-title">🏛️ <u>Health Systems Overview</u></div>
          ${this.createDataRows([
          ['System Type', this.formatValue(d.health_systems_overview?.system)],
          ['Universal Health Coverage (UHC)', this.formatValue(d.health_systems_overview?.uhc)],
          ['Health Access & Quality (HAQ)', this.formatValue(d.health_systems_overview?.haq)]
        ])}

          <div class="section-title">🏥 <u>Service Availability</u></div>
          ${this.createDataRows([
          ['Physicians per 10,000', this.formatValue(d.service_availability?.physicians)],
          ['Nurses per 10,000', this.formatValue(d.service_availability?.nurses)],
          ['Hospital Beds per 10,000', this.formatValue(d.service_availability?.beds)]
        ])}

<div class="section-title">💊 <u>Market Overview</u></div>
${this.createDataRows([
  ['Market Access Risk Score (MARS)', this.formatValue(d.market_overview?.mars)],
  ['Prescription', this.formatValue(d.market_overview?.prescription, false, true)],
  ['Generic', this.formatValue(d.market_overview?.generic, false, true)],
  ['Patented', this.formatValue(d.market_overview?.patented, false, true)],
  ['National Cancer Guideline', this.formatValue(d.market_overview?.national_cancer_guideline)],
  ['National Cancer Plan', this.formatValue(d.market_overview?.national_cancer_plan)]
])}

          <div class="section-title">💸 <u>Health Financing</u></div>
          ${this.createDataRows([
          ['Health Spending per capita', d.health_financing?.health_spending ? `$${this.formatValue(d.health_financing?.health_spending, true)}` : 'N/A'],
          ['External Funding', this.formatValue(d.health_financing?.external_funding, false, true)],
          ['OOP Funding', this.formatValue(d.health_financing?.oop_funding, false, true)],
          ['Government Funding', this.formatValue(d.health_financing?.government_funding, false, true)],
          ['Others', this.formatValue(d.health_financing?.others_funding, false, true)]
        ])}
        `;
      }

      createDataRows(rows) {
        return rows.map(([key, value]) =>
          `<div class="data-row"><div class="data-key">${key}</div><div class="data-value">${this.formatValue(value)}</div></div>`
        ).join('');
      }

      formatValue(val, isCurrency = false, isPercent = false) {
        const cacheKey = `${val}-${isCurrency}-${isPercent}`;
        if (this.formatCache.has(cacheKey)) {
          return this.formatCache.get(cacheKey);
        }

        let result;
        if (val === null || val === undefined || val === 'null' || (typeof val === 'number' && isNaN(val))) {
          result = 'N/A';
        } else if (isCurrency) {
          result = `${Number(val).toLocaleString()}`;
        } else if (isPercent) {
          result = `${val}%`;
        } else if (typeof val === 'string') {
          result = val.charAt(0).toUpperCase() + val.slice(1);
        } else {
          result = val;
        }

        this.formatCache.set(cacheKey, result);
        return result;
      }

      getVal(countryName, metric) {
        const country = this.countryData[countryName];
        if (!country) return undefined;

        for (const cat in this.config.categoryMetrics) {
          if (this.config.categoryMetrics[cat].includes(metric)) {
            return country[cat]?.[metric];
          }
        }
        return undefined;
      }

      toggleInfoPanel() {
        const currentVisible = this.state.get('ui.infoPanelVisible');
        this.state.set('ui.infoPanelVisible', !currentVisible);
      }

      updateInfoPanelVisibility(visible) {
        this.elements.infoBox.style.display = visible ? 'block' : 'none';
        this.elements.map.classList.toggle('full-width', !visible);
        document.querySelector('.toggle-info-btn').classList.toggle('panel-hidden', !visible);
        this.elements.toggleText.textContent = visible ? 'Hide Info' : 'Show Info';

        setTimeout(() => {
          this.map.invalidateSize();
        }, 300);
      }

      toggleComparePanel() {
        const currentVisible = this.state.get('ui.comparePanelVisible');
        this.state.set('ui.comparePanelVisible', !currentVisible);

        if (!currentVisible) {
          this.populateCompareDropdowns();
        }
      }

      populateCompareDropdowns() {
        const countries = Object.keys(this.countryData).sort();
        const selects = [document.getElementById('compareCountry1'), document.getElementById('compareCountry2')];

        selects.forEach(select => {
          select.innerHTML = `<option value="">Select ${select.id === 'compareCountry1' ? 'first' : 'second'} country</option>`;
          countries.forEach(country => {
            const option = document.createElement('option');
            option.value = country;
            option.textContent = country;
            select.appendChild(option);
          });
        });
      }

      compareCountries() {
        const country1 = document.getElementById('compareCountry1').value;
        const country2 = document.getElementById('compareCountry2').value;

        if (!country1 || !country2) {
          alert('Please select both countries to compare');
          return;
        }

        if (country1 === country2) {
          alert('Please select two different countries');
          return;
        }

        const data1 = this.countryData[country1];
        const data2 = this.countryData[country2];

        if (!data1 || !data2) {
          alert('Data not available for selected countries');
          return;
        }

        this.elements.compareInfo.innerHTML = this.createComparisonHTML(country1, country2, data1, data2);
        this.state.set('ui.compareModalVisible', true);
      }

      createComparisonHTML(country1, country2, data1, data2) {
        const sections = [
          {
            title: 'Demographics Indicators',
            metrics: [
              {key: 'Population', getter: d => d.demographics_indicators?.population?.toLocaleString(), compare: true},
              {key: 'Population Growth', getter: d => d.demographics_indicators?.population_growth, isPercent: true, compare: true},
              {key: 'Life Expectancy', getter: d => d.demographics_indicators?.life_expectancy, suffix: ' years', compare: true},
              {key: 'Urban Area %', getter: d => d.demographics_indicators?.urban_area, isPercent: true}
            ]
          },
          {
            title: 'Economic Indicators',
            metrics: [
              {key: 'GDP per capita', getter: d => d.economic_indicators?.gdp ? `$${d.economic_indicators?.gdp?.toLocaleString()}` : null, compare: true},
              {key: 'Income Group', getter: d => d.economic_indicators?.income_group},
              {key: 'GDP Growth', getter: d => d.economic_indicators?.gdp_growth, isPercent: true, compare: true},
              {key: 'GINI Index', getter: d => d.economic_indicators?.gini_index, compare: true, inverse: true}
            ]
          },
          {
            title: 'Health Systems Overview',
            metrics: [
              {key: 'System Type', getter: d => d.health_systems_overview?.system},
              {key: 'Universal Health Coverage (UHC)', getter: d => d.health_systems_overview?.uhc, compare: true},
              {key: 'Health Access & Quality (HAQ)', getter: d => d.health_systems_overview?.haq, compare: true}
            ]
          },
{
  title: 'Market Overview',
  metrics: [
    {key: 'Market Access Risk Score (MARS)', getter: d => d.market_overview?.mars, compare: true},
    {key: 'Prescription %', getter: d => d.market_overview?.prescription, isPercent: true},
    {key: 'Generic %', getter: d => d.market_overview?.generic, isPercent: true},
    {key: 'Patented %', getter: d => d.market_overview?.patented, isPercent: true},
    {key: 'National Cancer Guideline', getter: d => d.market_overview?.national_cancer_guideline},
    {key: 'National Cancer Plan', getter: d => d.market_overview?.national_cancer_plan}
  ]
},
          {
            title: 'Health Financing',
            metrics: [
              {key: 'Health Spending per capita', getter: d => d.health_financing?.health_spending ? `$${d.health_financing?.health_spending?.toLocaleString()}` : null, compare: true},
              {key: 'OOP Funding', getter: d => d.health_financing?.oop_funding, isPercent: true, compare: true, inverse: true},
              {key: 'Government Funding', getter: d => d.health_financing?.government_funding, isPercent: true, compare: true}
            ]
          }
        ];

        let html = `
          <button class="compare-close" onclick="app.state.set('ui.compareModalVisible', false)">×</button>
          <h2 style="margin-top: 0; color: #082032;">Country Comparison</h2>
          <h3 style="color: #666;">${country1} vs ${country2}</h3>
          <table class="compare-table">
            <thead>
              <tr>
                <th>Metric</th>
                <th>${country1}</th>
                <th>${country2}</th>
              </tr>
            </thead>
            <tbody>
        `;

        sections.forEach(section => {
          html += `<tr style="background-color: #e8f4f8;">
            <td colspan="3" style="font-weight: bold; color: #082032;">${section.title}</td>
          </tr>`;

          section.metrics.forEach(metric => {
            const val1 = metric.getter(data1);
            const val2 = metric.getter(data2);
            const class1 = metric.compare ? this.compareValues(val1, val2, metric.inverse) : '';
            const class2 = metric.compare ? this.compareValues(val2, val1, metric.inverse) : '';

            html += `<tr>
              <td class="metric-name">${metric.key}</td>
              <td class="${class1}">${this.formatValue(val1, metric.isCurrency, metric.isPercent)}${metric.suffix || ''}</td>
              <td class="${class2}">${this.formatValue(val2, metric.isCurrency, metric.isPercent)}${metric.suffix || ''}</td>
            </tr>`;
          });
        });

        html += '</tbody></table>';
        return html;
      }

      compareValues(val1, val2, inverse = false) {
        if (val1 == null || val2 == null) return 'value-equal';
        if (val1 === val2) return 'value-equal';

        if (inverse) {
          return val1 < val2 ? 'value-better' : 'value-worse';
        } else {
          return val1 > val2 ? 'value-better' : 'value-worse';
        }
      }

      resetView() {
        // Reset state
        this.state.set('filters.country', '');
        this.state.set('filters.category', 'economic_indicators');
        this.state.set('filters.metric', 'gdp');
        this.state.set('ui.comparePanelVisible', false);
        this.state.set('ui.compareModalVisible', false);
        this.state.set('currentInfo.country', 'All Countries');

        // Reset map view
        this.map.setView([40, 65], 2);
      }

      setLoading(loading) {
        this.state.set('ui.loading', loading);
        this.elements.map.classList.toggle('loading', loading);
      }

      setupMobileTouchHandlers() {
        let startY = 0;

        // Make the info header clickable to toggle panel
        const infoHeader = this.elements.infoBox?.querySelector('.info-header');
        if (infoHeader) {
          // Remove any existing listeners to avoid duplicates
          infoHeader.replaceWith(infoHeader.cloneNode(true));
          const newInfoHeader = this.elements.infoBox.querySelector('.info-header');

          newInfoHeader.addEventListener('click', () => {
            this.elements.infoBox.classList.toggle('active');
          });
        }

        // Add swipe gestures (remove existing listeners first)
        if (this.elements.infoBox) {
          const newInfoBox = this.elements.infoBox.cloneNode(true);
          this.elements.infoBox.replaceWith(newInfoBox);
          this.elements.infoBox = newInfoBox;

          this.elements.infoBox.addEventListener('touchstart', e => {
            startY = e.touches[0].clientY;
          });

          this.elements.infoBox.addEventListener('touchmove', e => {
            const currentY = e.touches[0].clientY;
            const diff = currentY - startY;

            if (diff > 50 && !this.elements.infoBox.classList.contains('active')) {
              this.elements.infoBox.classList.add('active');
            } else if (diff < -50 && this.elements.infoBox.classList.contains('active')) {
              this.elements.infoBox.classList.remove('active');
            }
          });
        }
      }


      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    }

    // Initialize the application
    const app = new WorldHeatmapApp();
    window.app = app; // Make it globally accessible for onclick handlers
  </script>
</body>

</html>